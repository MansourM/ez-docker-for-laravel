#!/usr/bin/env bash
# This script was generated by bashly 1.1.10 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
ez_usage() {
  if [[ -n $long_usage ]]; then
    printf "ez - easy to setup, robust and production ready environment for Laravel using Docker, Docker Compose and bash script.\n"
    echo

  else
    printf "ez - easy to setup, robust and production ready environment for Laravel using Docker, Docker Compose and bash script.\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  ez COMMAND\n"
  printf "  ez [COMMAND] --help | -h\n"
  printf "  ez --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Docker Commands\n" "docker "
  printf "  %s   Shared containers Commands\n" "shared "
  printf "  %s   Laravel containers Commands\n" "laravel"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  ez docker install\n"
    printf "  ez d i\n"
    echo

  fi
}

# :command.usage
ez_docker_usage() {
  if [[ -n $long_usage ]]; then
    printf "ez docker - Docker Commands\n"
    echo

  else
    printf "ez docker - Docker Commands\n"
    echo

  fi

  printf "Alias: d\n"
  echo

  printf "%s\n" "Usage:"
  printf "  ez docker COMMAND\n"
  printf "  ez docker [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   add docker repository to apt sources, then install docker engine\n" "install  "
  printf "  %s   uninstall docker engine\n" "uninstall"
  printf "  %s   removes all images, containers, and volumes, (You have to delete any edited configuration files manually)\n" "remove   "
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
ez_docker_install_usage() {
  if [[ -n $long_usage ]]; then
    printf "ez docker install - add docker repository to apt sources, then install docker engine\n"
    echo

  else
    printf "ez docker install - add docker repository to apt sources, then install docker engine\n"
    echo

  fi

  printf "Alias: i\n"
  echo

  printf "%s\n" "Usage:"
  printf "  ez docker install\n"
  printf "  ez docker install --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
ez_docker_uninstall_usage() {
  if [[ -n $long_usage ]]; then
    printf "ez docker uninstall - uninstall docker engine\n"
    echo

  else
    printf "ez docker uninstall - uninstall docker engine\n"
    echo

  fi

  printf "Alias: u\n"
  echo

  printf "%s\n" "Usage:"
  printf "  ez docker uninstall\n"
  printf "  ez docker uninstall --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
ez_docker_remove_usage() {
  if [[ -n $long_usage ]]; then
    printf "ez docker remove - removes all images, containers, and volumes, (You have to delete any edited configuration files manually)\n"
    echo

  else
    printf "ez docker remove - removes all images, containers, and volumes, (You have to delete any edited configuration files manually)\n"
    echo

  fi

  printf "Alias: r\n"
  echo

  printf "%s\n" "Usage:"
  printf "  ez docker remove\n"
  printf "  ez docker remove --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
ez_shared_usage() {
  if [[ -n $long_usage ]]; then
    printf "ez shared - Shared containers Commands\n"
    echo

  else
    printf "ez shared - Shared containers Commands\n"
    echo

  fi

  printf "Alias: s\n"
  echo

  printf "%s\n" "Usage:"
  printf "  ez shared COMMAND\n"
  printf "  ez shared [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   build and start shared containers\n" "deploy "
  printf "  %s   start shared containers\n" "start  "
  printf "  %s   stop shared containers\n" "stop   "
  printf "  %s   restart shared containers\n" "restart"
  printf "  %s   remove shared containers\n" "down   "
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
ez_shared_deploy_usage() {
  if [[ -n $long_usage ]]; then
    printf "ez shared deploy - build and start shared containers\n"
    echo

  else
    printf "ez shared deploy - build and start shared containers\n"
    echo

  fi

  printf "Alias: d\n"
  echo

  printf "%s\n" "Usage:"
  printf "  ez shared deploy\n"
  printf "  ez shared deploy --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
ez_shared_start_usage() {
  if [[ -n $long_usage ]]; then
    printf "ez shared start - start shared containers\n"
    echo

  else
    printf "ez shared start - start shared containers\n"
    echo

  fi

  printf "Alias: s\n"
  echo

  printf "%s\n" "Usage:"
  printf "  ez shared start\n"
  printf "  ez shared start --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
ez_shared_stop_usage() {
  if [[ -n $long_usage ]]; then
    printf "ez shared stop - stop shared containers\n"
    echo

  else
    printf "ez shared stop - stop shared containers\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  ez shared stop\n"
  printf "  ez shared stop --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
ez_shared_restart_usage() {
  if [[ -n $long_usage ]]; then
    printf "ez shared restart - restart shared containers\n"
    echo

  else
    printf "ez shared restart - restart shared containers\n"
    echo

  fi

  printf "Alias: r\n"
  echo

  printf "%s\n" "Usage:"
  printf "  ez shared restart\n"
  printf "  ez shared restart --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
ez_shared_down_usage() {
  if [[ -n $long_usage ]]; then
    printf "ez shared down - remove shared containers\n"
    echo

  else
    printf "ez shared down - remove shared containers\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  ez shared down\n"
  printf "  ez shared down --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
ez_laravel_usage() {
  if [[ -n $long_usage ]]; then
    printf "ez laravel - Laravel containers Commands\n"
    echo

  else
    printf "ez laravel - Laravel containers Commands\n"
    echo

  fi

  printf "Alias: l\n"
  echo

  printf "%s\n" "Usage:"
  printf "  ez laravel COMMAND\n"
  printf "  ez laravel [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   build and start Laravel containers\n" "deploy "
  printf "  %s   start Laravel containers\n" "start  "
  printf "  %s   stop Laravel containers\n" "stop   "
  printf "  %s   restart Laravel containers\n" "restart"
  printf "  %s   remove Laravel containers\n" "down   "
  printf "  %s   remove Laravel containers\n" "new    "
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
ez_laravel_deploy_usage() {
  if [[ -n $long_usage ]]; then
    printf "ez laravel deploy - build and start Laravel containers\n"
    echo

  else
    printf "ez laravel deploy - build and start Laravel containers\n"
    echo

  fi

  printf "Alias: d\n"
  echo

  printf "%s\n" "Usage:"
  printf "  ez laravel deploy APP_NAME APP_ENV\n"
  printf "  ez laravel deploy --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "APP_NAME"
    printf "    Laravel app name\n"
    echo

    # :argument.usage
    printf "  %s\n" "APP_ENV"
    printf "    Laravel app environment\n"
    printf "    Allowed: dev, test, staging, production\n"
    echo

  fi
}

# :command.usage
ez_laravel_start_usage() {
  if [[ -n $long_usage ]]; then
    printf "ez laravel start - start Laravel containers\n"
    echo

  else
    printf "ez laravel start - start Laravel containers\n"
    echo

  fi

  printf "Alias: s\n"
  echo

  printf "%s\n" "Usage:"
  printf "  ez laravel start APP_NAME APP_ENV\n"
  printf "  ez laravel start --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "APP_NAME"
    printf "    Laravel app name\n"
    echo

    # :argument.usage
    printf "  %s\n" "APP_ENV"
    printf "    Laravel app environment\n"
    printf "    Allowed: dev, test, staging, production\n"
    echo

  fi
}

# :command.usage
ez_laravel_stop_usage() {
  if [[ -n $long_usage ]]; then
    printf "ez laravel stop - stop Laravel containers\n"
    echo

  else
    printf "ez laravel stop - stop Laravel containers\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  ez laravel stop APP_NAME APP_ENV\n"
  printf "  ez laravel stop --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "APP_NAME"
    printf "    Laravel app name\n"
    echo

    # :argument.usage
    printf "  %s\n" "APP_ENV"
    printf "    Laravel app environment\n"
    printf "    Allowed: dev, test, staging, production\n"
    echo

  fi
}

# :command.usage
ez_laravel_restart_usage() {
  if [[ -n $long_usage ]]; then
    printf "ez laravel restart - restart Laravel containers\n"
    echo

  else
    printf "ez laravel restart - restart Laravel containers\n"
    echo

  fi

  printf "Alias: r\n"
  echo

  printf "%s\n" "Usage:"
  printf "  ez laravel restart APP_NAME APP_ENV\n"
  printf "  ez laravel restart --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "APP_NAME"
    printf "    Laravel app name\n"
    echo

    # :argument.usage
    printf "  %s\n" "APP_ENV"
    printf "    Laravel app environment\n"
    printf "    Allowed: dev, test, staging, production\n"
    echo

  fi
}

# :command.usage
ez_laravel_down_usage() {
  if [[ -n $long_usage ]]; then
    printf "ez laravel down - remove Laravel containers\n"
    echo

  else
    printf "ez laravel down - remove Laravel containers\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  ez laravel down APP_NAME APP_ENV\n"
  printf "  ez laravel down --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "APP_NAME"
    printf "    Laravel app name\n"
    echo

    # :argument.usage
    printf "  %s\n" "APP_ENV"
    printf "    Laravel app environment\n"
    printf "    Allowed: dev, test, staging, production\n"
    echo

  fi
}

# :command.usage
ez_laravel_new_usage() {
  if [[ -n $long_usage ]]; then
    printf "ez laravel new - remove Laravel containers\n"
    echo

  else
    printf "ez laravel new - remove Laravel containers\n"
    echo

  fi

  printf "Alias: n\n"
  echo

  printf "%s\n" "Usage:"
  printf "  ez laravel new\n"
  printf "  ez laravel new --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
  local arg flags passthru
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.user_lib
# src/lib/ask_question.sh
ask_question() {
    local question=$1
    local default=$2
    local result

    local GREEN='\033[0;32m'
    local YELLOW='\033[0;33m'
    local NC='\033[0m' # No Color

    # Prompt the user with the question and default answer
    read -p "$(echo -e "${GREEN}$question ${YELLOW}[$default]${NC}: ")" result

    # Use the default if the user presses Enter without typing anything
    if [[ -z "$result" ]]; then
        result=$default
    fi

    echo $result
}

# src/lib/ask_question_v2.sh
#TODO This is WIP, read, echo does not work
ask_question_v2() {
    local question=$1
    local default=$2
    local regex=$3
    local required=$4
    local hide_text=$5

    local result

    local GREEN='\033[0;32m'
    local YELLOW='\033[0;33m'
    local RED='\033[0;31m'
    local NC='\033[0m' # No Color

    while true; do
        # Prompt the user with the question and default answer
        if [ "$hide_text" == "true" ]; then
            read -s -p "$(echo -e "${GREEN}$question ${YELLOW}[$default]${NC}: ")" result
            echo ""  # Move to a new line after hidden input
        else
            read -p "$(echo -e "${GREEN}$question ${YELLOW}[$default]${NC}: ")" result
        fi

        # Use the default if the user presses Enter without typing anything
        if [[ -z "$result" ]]; then
            result=$default
        fi

        # Check if the result is required
        if [ "$required" == "true" ] && [[ -z "$result" ]]; then
            echo -e "${RED}This field is required.${NC}"
            continue
        fi

        # Check if the result matches the regex
        if [ -n "$regex" ] && ! [[ "$result" =~ $regex ]]; then
            echo -e "${RED}Invalid input format, should match regex: '$regex'${NC}"
            continue
        fi

        break
    done

    echo $result
}

# src/lib/check_containers.sh
check_containers() {
    log_header "Checking shared containers health before building the Laravel container."
    local containers=("$@")
    local retries=4
    local delay=10

    for container in "${containers[@]}"; do
        for attempt in $(seq 1 $((retries + 1))); do
            if is_container_running "$container"; then
                log_success "Container '$container' is running."
                if is_container_healthy "$container"; then
                    log_success "Container '$container' is healthy."
                    break
                else
                    log_warning "Container '$container' is not healthy. Attempt $((attempt))/$retries."
                fi
            else
                log_warning "Container '$container' is not running. Attempt $((attempt))/$retries. You can run shared container by './ez shared deploy'"
            fi

            if [ $attempt -gt $retries ]; then
                log_error "Container '$container' is not healthy or not running after $retries attempts."
                exit 1
            fi

            log_info "Retrying in $delay seconds: "
            for ((i=0; i<$delay; i++)); do
                echo -n "."
                sleep 1
            done
            echo ""
        done
    done
}

# src/lib/create_docker_env.sh
create_docker_env() {
  cat <<EOL > "$DOCKER_ENV_PATH"
  SHARED_NETWORK_NAME=$SHARED_NETWORK_NAME

  PORT_NGINX_PM=$PORT_NGINX_PM
  PORT_PMA=$PORT_PMA

  DB_HOST=mysql8
  DB_PORT=3306
  DB_ROOT_PASSWORD=$DB_ROOT_PASSWORD
EOL

  log_success "Saved docker environment variables to $DOCKER_ENV_PATH"
}

# src/lib/create_new_database_and_user.sh
create_new_database_and_user() {

  if [ "$#" -ne 3 ]; then
      log_error "Invalid Arguments, Usage: $0 <new_db_name> <new_user_name> <new_user_password>"
      return 1
  fi

  # Set variables
  NEW_DB_NAME=$1
  NEW_USER_NAME=$2
  NEW_USER_PASSWORD=$3

  log_header "Creating Database: $NEW_DB_NAME with User: $NEW_USER_NAME"

  MYSQL_USER="root"
  # DB_ROOT_PASSWORD is read from docker.env

  # Check if database exists (improve error handling)
  if ! docker exec -i $DB_HOST mysql -u$MYSQL_USER -p$DB_ROOT_PASSWORD -e "SELECT 1 FROM \`$NEW_DB_NAME\`;" > /dev/null 2>&1; then
    # Create database
    if ! docker exec -i $DB_HOST mysql -u$MYSQL_USER -p$DB_ROOT_PASSWORD -e "CREATE DATABASE IF NOT EXISTS \`$NEW_DB_NAME\`;"; then
      log
      log_error "Failed to create database '$NEW_DB_NAME'"
      exit 1
    else
      log_success "Created Database: $NEW_DB_NAME";
    fi
  else
    log "Database: $NEW_DB_NAME Already Exists";
  fi

  #TODO how to give access to specific container instead of %?
  # Check if user exists (improve error handling)
  if ! docker exec -i $DB_HOST mysql -u$MYSQL_USER -p$DB_ROOT_PASSWORD -e "SELECT user FROM mysql.user WHERE user='$NEW_USER_NAME';" --skip-column-names -B | grep -q "$NEW_USER_NAME"; then
    # Create user and grant privileges
    if ! docker exec -i $DB_HOST mysql -u$MYSQL_USER -p$DB_ROOT_PASSWORD -e "CREATE USER '$NEW_USER_NAME'@'%' IDENTIFIED BY '$NEW_USER_PASSWORD';" || \
       ! docker exec -i $DB_HOST mysql -u$MYSQL_USER -p$DB_ROOT_PASSWORD -e "GRANT ALL PRIVILEGES ON \`$NEW_DB_NAME\`.* TO '$NEW_USER_NAME'@'%';" || \
       ! docker exec -i $DB_HOST mysql -u$MYSQL_USER -p$DB_ROOT_PASSWORD -e "FLUSH PRIVILEGES;"; then
      log_error "Failed to create and grant privileges for user '$NEW_USER_NAME'"
      exit 1
    fi
    log_success "User: '$NEW_USER_NAME' created for DB: $NEW_DB_NAME with full privileges";
  else
    log "User '$NEW_USER_NAME' already exists";
  fi
}

# src/lib/generate_password.sh
generate_password() {
    local length=$1
    local charset="A-Za-z0-9@#%&*"
    tr -dc "$charset" </dev/urandom | head -c $length
}

# src/lib/get_prompt_text.sh
get_prompt_text() {
    local question=$1
    local default=$2

    local GREEN='\033[0;32m'
    local YELLOW='\033[0;33m'
    local NO_COLOR='\033[0m'

    echo "${GREEN}$question ${YELLOW}[$default]${NO_COLOR}: "
}

# src/lib/is_container_healthy.sh
is_container_healthy() {
    local container_name=$1
    local health_status=$(docker inspect --format='{{.State.Health.Status}}' "$container_name")
    if [ "$health_status" == "healthy" ]; then
        return 0
    else
        return 1
    fi
}

# src/lib/is_container_running.sh
is_container_running() {
    local container_name=$1
    docker ps --filter "name=$container_name" --filter "status=running" --format '{{.Names}}' | grep -w "$container_name" > /dev/null
    return $?
}

# src/lib/load_env.sh
load_env() {
  local filePath="${1:-.env}"

  if [ ! -f "$filePath" ]; then
    echo "missing ${filePath}"
    exit 1
  fi

  log "Reading $filePath"
  while read -r LINE; do
    # Remove leading and trailing whitespaces, and carriage return
    CLEANED_LINE=$(echo "$LINE" | awk '{$1=$1};1' | tr -d '\r')

    if [[ $CLEANED_LINE != '#'* ]] && [[ $CLEANED_LINE == *'='* ]]; then
      export "$CLEANED_LINE"
    fi
  done < "$filePath"
}

# src/lib/log.sh
log() {
  if [ "$#" -ne 1 ]; then
      echo -e "\nInvalid Arguments, Usage: $0 <message>\n"
      return 1
  fi

  echo "-- $1"
}

# src/lib/log_error.sh
log_error() {
  if [ "$#" -ne 1 ]; then
      echo -e "\nInvalid Arguments, Usage: $0 <message>\n"
      return 1
  fi

  RED='\033[0;31m'
  NORMAL='\033[0m'

  echo -e "${RED}-- $1${NORMAL}"
}

# src/lib/log_header.sh
log_header() {
  if [ "$#" -ne 1 ]; then
      echo -e "\nInvalid Arguments, Usage: $0 <message>\n"
      return 1
  fi

  BOLD_CYAN='\033[1;36m'
  NORMAL='\033[0m'

  echo -e "\n${BOLD_CYAN}==[ $1 ]==\n${NORMAL}"
}

# src/lib/log_info.sh
log_info() {
  if [ "$#" -ne 1 ]; then
      echo -e "\nInvalid Arguments, Usage: $0 <message>\n"
      return 1
  fi

  BOLD_CYAN='\033[1;36m'
  NORMAL='\033[0m'

  echo -e "${BOLD_CYAN}-- $1${NORMAL}"
}

# src/lib/log_success.sh
log_success() {
  if [ "$#" -ne 1 ]; then
      echo -e "\nInvalid Arguments, Usage: $0 <message>\n"
      return 1
  fi

  GREEN='\033[0;32m'
  NORMAL='\033[0m'

  echo -e "${GREEN}-- $1${NORMAL}"
}

# src/lib/log_warning.sh
log_warning() {
  if [ "$#" -ne 1 ]; then
      echo -e "\nInvalid Arguments, Usage: $0 <message>\n"
      return 1
  fi

  YELLOW='\033[0;33m'
  NORMAL='\033[0m'

  echo -e "${YELLOW}-- $1${NORMAL}"
}

# src/lib/merge_envs.sh
merge_envs() {
  if [ "$#" -lt 3 ]; then
    log_error "Usage: merge_env <output> <file1> <file2> [file3 ... fileN]"
    exit 1
  fi

  local output="$1"
  shift

  local merged_content=""

  for file in "$@"; do
    if [ ! -e "$file" ]; then
      log_error "$file does not exist!"
      exit 1
    fi

    # Sort, filter, and remove duplicates from merged content
    merged_content=$(sort -u -t '=' -k 1,1 "$file" <(printf "%s" "$merged_content") | grep -v '^$\|^\s*\#')
  done

  #Mask some vars from being merged into others, TODO improve this part
  merged_content=$(echo "$merged_content" | grep -Ev '^(SHARED_NETWORK_NAME|DB_ROOT_PASSWORD|GIT_URL)=')

  echo "$merged_content" > "$output"
  log_success "Merged files into $output."
}

# src/lib/read_multi_line_input.sh
read_multi_line_input() {
    local delimiter=$1
    local result

    result=""
    while IFS= read -r line; do
        [[ $line == "$delimiter" ]] && break
        result+="$line"$'\n'
    done

    echo "$result"
}

# src/lib/setup_environment.sh
setup_environment() {
  local app_name=$1
  local environment=$2

  local branch_name db_database db_username generated_password db_password app_debug

  if [ "$environment" == "production" ]; then
    branch_name="main"
  else
    branch_name="$environment"
  fi

  branch_name=$(ask_question "Enter the ${environment} branch name" "$branch_name")

  db_database=$(ask_question "Enter the ${environment} database name" "${app_name}_${environment}")
  db_username=$(ask_question "Enter the ${environment} database username" "${app_name}_${environment}_user")
  generated_password=$(generate_password 20)
  db_password=$(ask_question "Enter the $db_username's password" "$generated_password")

  if [[ "$environment" == "dev" || "$environment" == "test" ]]; then
    app_debug=true
    # Determine the dev/test app port based on the number of folders in the apps directory
    local num_apps=$(ls -l apps | grep -c '^d')
    # fixme now that we have dev, dev and test need to both have ports (now both use same port)
    local default_port=$((7999 + num_apps))
    app_port=$(ask_question "Enter the ${environment} app port" "$default_port")
  else
    app_debug=false
  fi

  #FIXME do something for APP_URL
  cat <<EOL > "apps/$app_name/env/$environment.env"
GIT_BRANCH=$branch_name
APP_ENV=$environment
APP_DEBUG=$app_debug
APP_URL=$environment.my.url
APP_PORT=$app_port
DB_DATABASE=$db_database
DB_USERNAME=$db_username
DB_PASSWORD=$db_password
EOL

}

# :command.command_functions

# :command.function
ez_docker_install_command() {
  # src/docker_install_command.sh
  #inspect_args

  apt-get update
  apt-get -y install ca-certificates curl gnupg
  install -m 0755 -d /etc/apt/keyrings
  curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpg
  chmod a+r /etc/apt/keyrings/docker.gpg

  # Add the repository to Apt sources:
  echo \
    "deb [arch="$(dpkg --print-architecture)" signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
      "$(. /etc/os-release && echo "$VERSION_CODENAME")" stable" |
    tee /etc/apt/sources.list.d/docker.list >/dev/null
  apt-get update

  apt-get -y install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin

  # Validate the success of the installation
  if [ $? -ne 0 ]; then
      log_error "Failed to install Docker and related packages"
      exit 1
  fi

}

# :command.function
ez_docker_uninstall_command() {
  # src/docker_uninstall_command.sh
  #inspect_args

  apt-get purge docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin docker-ce-rootless-extras

}

# :command.function
ez_docker_remove_command() {
  # src/docker_remove_command.sh
  #inspect_args

  rm -rf /var/lib/docker
  rm -rf /var/lib/containerd

}

# :command.function
ez_shared_deploy_command() {
  # src/shared_deploy_command.sh
  DOCKER_ENV_PATH="docker/docker.env"

  if [[ -f "$DOCKER_ENV_PATH" ]]; then
    load_env "$DOCKER_ENV_PATH"
  else
    log_warning "$DOCKER_ENV_PATH not found."
    log_info "Creating new '$DOCKER_ENV_PATH' file."

    PORT_NGINX_PM=$(ask_question "Enter the Nginx Proxy Manager port" "7000")
    PORT_PMA=$(ask_question "Enter the PhpMyAdmin port" "7001")
    GENERATED_PASSWORD=$(generate_password 24)
    DB_ROOT_PASSWORD=$(ask_question "Enter the database root password" "$GENERATED_PASSWORD" )
    SHARED_NETWORK_NAME=$(ask_question "Enter the docker network name" "ez-shared-network")

    cat <<EOL > "$DOCKER_ENV_PATH"
SHARED_NETWORK_NAME=$SHARED_NETWORK_NAME

PORT_NGINX_PM=$PORT_NGINX_PM
PORT_PMA=$PORT_PMA

DB_HOST=mysql8
DB_PORT=3306
DB_ROOT_PASSWORD=$DB_ROOT_PASSWORD
EOL

    log_success "Saved docker environment variables to $DOCKER_ENV_PATH"
  fi

  # Check if the network already exists
  if docker network inspect "$SHARED_NETWORK_NAME" >/dev/null 2>&1; then
    log "Network '$SHARED_NETWORK_NAME' already exists"
  else
    docker network create "$SHARED_NETWORK_NAME"
    if [ $? -eq 0 ]; then
      log_success "Network '$SHARED_NETWORK_NAME' created"
    else
      log_error "Failed to create network '$SHARED_NETWORK_NAME'"
      exit 1
    fi
  fi

  log_header "Running Docker Compose for shared services"

  docker compose -f docker/compose-shared.yml --env-file "docker/docker.env" up --build -d
  if [ $? -ne 0 ]; then
    log_error "Failed to run Docker Compose"
    exit 1
  fi

}

# :command.function
ez_shared_start_command() {
  # src/shared_start_command.sh
  #inspect_args

  load_env "docker/docker.env"

  docker compose -f docker/compose-shared.yml start

}

# :command.function
ez_shared_stop_command() {
  # src/shared_stop_command.sh
  #inspect_args

  load_env "docker/docker.env"

  docker compose -f docker/compose-shared.yml stop

}

# :command.function
ez_shared_restart_command() {
  # src/shared_restart_command.sh
  #inspect_args

  load_env "docker/docker.env"

  docker compose -f docker/compose-shared.yml restart

}

# :command.function
ez_shared_down_command() {
  # src/shared_down_command.sh
  #inspect_args

  load_env "docker/docker.env"

  docker compose -f docker/compose-shared.yml  down

}

# :command.function
ez_laravel_deploy_command() {
  # src/laravel_deploy_command.sh
  inspect_args
  log_header "Preparing to deploy Laravel in ${args[APP_ENV]} mode"

  app_dir="apps/${args[APP_NAME]}"
  if [[ ! -d "$app_dir" ]]; then
      log_error "Directory $app_dir does not exist! you need to setup your app first, try './ez laravel new'"
      exit 1
  fi

  laravel_env_path="$app_dir/env/laravel.env"
  docker_env_path="docker/docker.env"
  app_env_path="$app_dir/env/app.env"
  override_env_path="$app_dir/env/${args[APP_ENV]}.env"
  merged_env_path="$app_dir/env/generated/${args[APP_ENV]}.env"

  merge_envs "$merged_env_path" "$laravel_env_path" "$docker_env_path" "$app_env_path" "$override_env_path"

  load_env "$docker_env_path"
  load_env "$app_env_path"
  load_env "$merged_env_path"

  SOURCE_CODE_DIR="$app_dir/src-${args[APP_ENV]}"
  #TODO add a force clone config somewhere so user can choose to always clone instead of updating the repo?
  log_info "Preparing source code"
  if [ -d "$SOURCE_CODE_DIR" ]; then
      log "Updating existing $SOURCE_CODE_DIR folder"

      cd "$SOURCE_CODE_DIR" || exit 1

      git pull origin "$GIT_BRANCH"
      if [ $? -ne 0 ]; then
          log_error "Error: Git pull failed."
          exit 1
      fi

      cd - || exit 1
  else
      log "Cloning new $SOURCE_CODE_DIR folder"
      git clone --depth 1 -b "$GIT_BRANCH" "$GIT_URL" "$SOURCE_CODE_DIR"

      # Check if cloning was successful
      if [ $? -ne 0 ]; then
          log_error "Error: Git cloning failed."
          exit 1
      fi
  fi

  containers=("nginx-pm" "mysql8")
  check_containers "${containers[@]}"

  create_new_database_and_user "$DB_DATABASE" "$DB_USERNAME" "$DB_PASSWORD"

  if [[ "${args[APP_ENV]}" == "dev" ]]; then
    cp "$merged_env_path" "$app_dir/.env"
  fi

  log_header "Running Docker Compose for Laravel ${args[APP_ENV]}"
  docker compose -f "$app_dir/compose-laravel.yml" --profile "${args[APP_ENV]}" --env-file "$merged_env_path" up --build -d

  if [ $? -ne 0 ]; then
    log_error "Docker Compose up failed for app: ${args[APP_NAME]}, environment: ${args[APP_ENV]}"
    exit 1
  fi

  log_success "Server running on [${args[APP_NAME]}_${args[APP_ENV]}] container with 'inner' port 80."
  log_info "You can connect your website to a domain using Nginx Proxy Manager at [<your_ip>:$PORT_NGINX_PM]."

  if [[ "${args[APP_ENV]}" == "dev" || "${args[APP_ENV]}" == "test" ]]; then
    if [[ -n "$APP_PORT" ]]; then
      log_success "Server running on [http://<your_ip>:$APP_PORT]."
    else
    log_warning "APP_PORT not set for test environment. Set it in 'apps/${args[APP_NAME]}/env/test.env'."
    fi
  fi

}

# :command.function
ez_laravel_start_command() {
  # src/laravel_start_command.sh
  docker compose -f "apps/${args[APP_NAME]}/compose-laravel.yml" --profile "${args[APP_ENV]}" start

}

# :command.function
ez_laravel_stop_command() {
  # src/laravel_stop_command.sh
  docker compose -f "apps/${args[APP_NAME]}/compose-laravel.yml" --profile "${args[APP_ENV]}" stop

}

# :command.function
ez_laravel_restart_command() {
  # src/laravel_restart_command.sh
  docker compose -f "apps/${args[APP_NAME]}/compose-laravel.yml" --profile "${args[APP_ENV]}" restart

}

# :command.function
ez_laravel_down_command() {
  # src/laravel_down_command.sh
  #TODO add better logs to laravel commands?
  docker compose -f "apps/${args[APP_NAME]}/compose-laravel.yml" --profile "${args[APP_ENV]}" down

}

# :command.function
ez_laravel_new_command() {
  # src/laravel_new_command.sh
  DELIMITER="exit"
  PROMPT=$(get_prompt_text "Please paste the content of your .env file, " "type '$DELIMITER' on a new line and press enter to finish")
  echo -e "$PROMPT"
  ENV_CONTENT=$(read_multi_line_input "$DELIMITER")

  APP_NAME=$(echo "$ENV_CONTENT" | grep -oP '^APP_NAME=\K.*')
  APP_NAME=$(ask_question "Enter the application name" "$APP_NAME")

  APP_DIR="apps/$APP_NAME"

  if [[ -d "$APP_DIR" ]]; then
      log_error "Directory $APP_DIR already exists app_name must be unique."
      exit 1
  fi

  log "Creating $APP_DIR directory"
  mkdir -p "$APP_DIR/env/generated"

  log "saving .env file into $APP_DIR/env/laravel.env"
  echo "$ENV_CONTENT" > "$APP_DIR/env/laravel.env"

  log_info "Git url examples:"
  log "normal git url (you get prompted for authorization): https://github.com/MansourM/ez-docker-for-laravel.git"
  log "or this format: https://<user>:<pass>@github.com/MansourM/ez-docker-for-laravel.git"
  GIT_URL=$(ask_question "Enter the application git url" "https://github.com/MansourM/ez-docker-for-laravel-example.git")

  cat <<EOL > "$APP_DIR/env/app.env"
GIT_URL=$GIT_URL
EOL

  SETUP_DEV_ENV=$(ask_question "Do you want to set up the dev environment?" "yes")

  if [[ "$SETUP_DEV_ENV" == "yes" || "$SETUP_DEV_ENV" == "y" ]]; then
    setup_environment "$APP_NAME" "test"
  fi

  SETUP_TEST_ENV=$(ask_question "Do you want to set up the test environment?" "yes")

  if [[ "$SETUP_TEST_ENV" == "yes" || "$SETUP_TEST_ENV" == "y" ]]; then
    setup_environment "$APP_NAME" "test"
  fi

  SETUP_STAGING_ENV=$(ask_question "Do you want to set up the staging environment?" "yes")

  if [[ "$SETUP_STAGING_ENV" == "yes" || "$SETUP_TEST_ENV" == "y" ]]; then
    setup_environment "$APP_NAME" "staging"
  fi

  SETUP_STAGING_ENV=$(ask_question "Do you want to set up the production environment?" "yes")

  if [[ "$SETUP_STAGING_ENV" == "yes" || "$SETUP_TEST_ENV" == "y" ]]; then
    setup_environment "$APP_NAME" "production"
  fi

  cp -r "template/nginx" "$APP_DIR/nginx"
  cp "template/entrypoint.sh" "$APP_DIR/entrypoint.sh"
  cp "template/entrypoint-dev.sh" "$APP_DIR/entrypoint-dev.sh"
  cp "template/opcache.ini" "$APP_DIR/opcache.ini"
  cp "template/php.ini" "$APP_DIR/php.ini"
  cp "template/supervisord.conf" "$APP_DIR/supervisord.conf"

  cp "template/common-laravel.yml" "$APP_DIR/common-laravel.yml"
  cp "template/laravel-dev.Dockerfile" "$APP_DIR/laravel-dev.Dockerfile"
  cp "template/laravel.Dockerfile" "$APP_DIR/laravel.Dockerfile"
  cp "template/compose-laravel.yml" "$APP_DIR/compose-laravel.yml"

}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        ez_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    docker | d)
      action="docker"
      shift
      ez_docker_parse_requirements "$@"
      shift $#
      ;;

    shared | s)
      action="shared"
      shift
      ez_shared_parse_requirements "$@"
      shift $#
      ;;

    laravel | l)
      action="laravel"
      shift
      ez_laravel_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      ez_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
ez_docker_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        ez_docker_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    install | i)
      action="install"
      shift
      ez_docker_install_parse_requirements "$@"
      shift $#
      ;;

    uninstall | u)
      action="uninstall"
      shift
      ez_docker_uninstall_parse_requirements "$@"
      shift $#
      ;;

    remove | r)
      action="remove"
      shift
      ez_docker_remove_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      ez_docker_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
ez_docker_install_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        ez_docker_install_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="docker install"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
ez_docker_uninstall_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        ez_docker_uninstall_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="docker uninstall"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
ez_docker_remove_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        ez_docker_remove_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="docker remove"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
ez_shared_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        ez_shared_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    deploy | d)
      action="deploy"
      shift
      ez_shared_deploy_parse_requirements "$@"
      shift $#
      ;;

    start | s)
      action="start"
      shift
      ez_shared_start_parse_requirements "$@"
      shift $#
      ;;

    stop)
      action="stop"
      shift
      ez_shared_stop_parse_requirements "$@"
      shift $#
      ;;

    restart | r)
      action="restart"
      shift
      ez_shared_restart_parse_requirements "$@"
      shift $#
      ;;

    down)
      action="down"
      shift
      ez_shared_down_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      ez_shared_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
ez_shared_deploy_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        ez_shared_deploy_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="shared deploy"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
ez_shared_start_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        ez_shared_start_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="shared start"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
ez_shared_stop_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        ez_shared_stop_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="shared stop"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
ez_shared_restart_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        ez_shared_restart_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="shared restart"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
ez_shared_down_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        ez_shared_down_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="shared down"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
ez_laravel_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        ez_laravel_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    deploy | d)
      action="deploy"
      shift
      ez_laravel_deploy_parse_requirements "$@"
      shift $#
      ;;

    start | s)
      action="start"
      shift
      ez_laravel_start_parse_requirements "$@"
      shift $#
      ;;

    stop)
      action="stop"
      shift
      ez_laravel_stop_parse_requirements "$@"
      shift $#
      ;;

    restart | r)
      action="restart"
      shift
      ez_laravel_restart_parse_requirements "$@"
      shift $#
      ;;

    down)
      action="down"
      shift
      ez_laravel_down_parse_requirements "$@"
      shift $#
      ;;

    new | n)
      action="new"
      shift
      ez_laravel_new_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      ez_laravel_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
ez_laravel_deploy_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        ez_laravel_deploy_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="laravel deploy"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['APP_NAME']+x} ]]; then
          args['APP_NAME']=$1
          shift
        # :argument.case
        elif [[ -z ${args['APP_ENV']+x} ]]; then
          args['APP_ENV']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['APP_NAME']+x} ]]; then
    printf "missing required argument: APP_NAME\nusage: ez laravel deploy APP_NAME APP_ENV\n" >&2
    exit 1
  fi
  if [[ -z ${args['APP_ENV']+x} ]]; then
    printf "missing required argument: APP_ENV\nusage: ez laravel deploy APP_NAME APP_ENV\n" >&2
    exit 1
  fi

  # :command.whitelist_filter
  if [[ -n ${args['APP_ENV']:-} ]] && [[ ! ${args['APP_ENV']:-} =~ ^(dev|test|staging|production)$ ]]; then
    printf "%s\n" "APP_ENV must be one of: dev, test, staging, production" >&2
    exit 1
  fi

}

# :command.parse_requirements
ez_laravel_start_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        ez_laravel_start_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="laravel start"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['APP_NAME']+x} ]]; then
          args['APP_NAME']=$1
          shift
        # :argument.case
        elif [[ -z ${args['APP_ENV']+x} ]]; then
          args['APP_ENV']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['APP_NAME']+x} ]]; then
    printf "missing required argument: APP_NAME\nusage: ez laravel start APP_NAME APP_ENV\n" >&2
    exit 1
  fi
  if [[ -z ${args['APP_ENV']+x} ]]; then
    printf "missing required argument: APP_ENV\nusage: ez laravel start APP_NAME APP_ENV\n" >&2
    exit 1
  fi

  # :command.whitelist_filter
  if [[ -n ${args['APP_ENV']:-} ]] && [[ ! ${args['APP_ENV']:-} =~ ^(dev|test|staging|production)$ ]]; then
    printf "%s\n" "APP_ENV must be one of: dev, test, staging, production" >&2
    exit 1
  fi

}

# :command.parse_requirements
ez_laravel_stop_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        ez_laravel_stop_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="laravel stop"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['APP_NAME']+x} ]]; then
          args['APP_NAME']=$1
          shift
        # :argument.case
        elif [[ -z ${args['APP_ENV']+x} ]]; then
          args['APP_ENV']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['APP_NAME']+x} ]]; then
    printf "missing required argument: APP_NAME\nusage: ez laravel stop APP_NAME APP_ENV\n" >&2
    exit 1
  fi
  if [[ -z ${args['APP_ENV']+x} ]]; then
    printf "missing required argument: APP_ENV\nusage: ez laravel stop APP_NAME APP_ENV\n" >&2
    exit 1
  fi

  # :command.whitelist_filter
  if [[ -n ${args['APP_ENV']:-} ]] && [[ ! ${args['APP_ENV']:-} =~ ^(dev|test|staging|production)$ ]]; then
    printf "%s\n" "APP_ENV must be one of: dev, test, staging, production" >&2
    exit 1
  fi

}

# :command.parse_requirements
ez_laravel_restart_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        ez_laravel_restart_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="laravel restart"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['APP_NAME']+x} ]]; then
          args['APP_NAME']=$1
          shift
        # :argument.case
        elif [[ -z ${args['APP_ENV']+x} ]]; then
          args['APP_ENV']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['APP_NAME']+x} ]]; then
    printf "missing required argument: APP_NAME\nusage: ez laravel restart APP_NAME APP_ENV\n" >&2
    exit 1
  fi
  if [[ -z ${args['APP_ENV']+x} ]]; then
    printf "missing required argument: APP_ENV\nusage: ez laravel restart APP_NAME APP_ENV\n" >&2
    exit 1
  fi

  # :command.whitelist_filter
  if [[ -n ${args['APP_ENV']:-} ]] && [[ ! ${args['APP_ENV']:-} =~ ^(dev|test|staging|production)$ ]]; then
    printf "%s\n" "APP_ENV must be one of: dev, test, staging, production" >&2
    exit 1
  fi

}

# :command.parse_requirements
ez_laravel_down_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        ez_laravel_down_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="laravel down"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['APP_NAME']+x} ]]; then
          args['APP_NAME']=$1
          shift
        # :argument.case
        elif [[ -z ${args['APP_ENV']+x} ]]; then
          args['APP_ENV']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['APP_NAME']+x} ]]; then
    printf "missing required argument: APP_NAME\nusage: ez laravel down APP_NAME APP_ENV\n" >&2
    exit 1
  fi
  if [[ -z ${args['APP_ENV']+x} ]]; then
    printf "missing required argument: APP_ENV\nusage: ez laravel down APP_NAME APP_ENV\n" >&2
    exit 1
  fi

  # :command.whitelist_filter
  if [[ -n ${args['APP_ENV']:-} ]] && [[ ! ${args['APP_ENV']:-} =~ ^(dev|test|staging|production)$ ]]; then
    printf "%s\n" "APP_ENV must be one of: dev, test, staging, production" >&2
    exit 1
  fi

}

# :command.parse_requirements
ez_laravel_new_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        ez_laravel_new_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="laravel new"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.user_hooks
before_hook() {
  # src/before.sh
  #inspect_args

  if [[ $EUID -ne 0 ]]; then
     log_error "This script must be run as root"
     exit 1
  fi
}

# :command.initialize
initialize() {
  version="0.3.0"
  long_usage=''
  set -e

}

# :command.run
run() {
  declare -A args=()
  declare -A deps=()
  declare -a other_args=()
  declare -a env_var_names=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"
  before_hook

  case "$action" in
    "docker") ez_docker_command ;;
    "docker install") ez_docker_install_command ;;
    "docker uninstall") ez_docker_uninstall_command ;;
    "docker remove") ez_docker_remove_command ;;
    "shared") ez_shared_command ;;
    "shared deploy") ez_shared_deploy_command ;;
    "shared start") ez_shared_start_command ;;
    "shared stop") ez_shared_stop_command ;;
    "shared restart") ez_shared_restart_command ;;
    "shared down") ez_shared_down_command ;;
    "laravel") ez_laravel_command ;;
    "laravel deploy") ez_laravel_deploy_command ;;
    "laravel start") ez_laravel_start_command ;;
    "laravel stop") ez_laravel_stop_command ;;
    "laravel restart") ez_laravel_restart_command ;;
    "laravel down") ez_laravel_down_command ;;
    "laravel new") ez_laravel_new_command ;;
  esac
}

initialize
run "$@"
